#!/usr/bin/env python

#
# Author: Jesus Galaz, 10/20/2012; last update 11/15/2012
# Copyright (c) 2011 Baylor College of Medicine
#
# This software is issued under a joint BSD/GNU license. You may use the
# source code in this file under either license. However, note that the
# complete EMAN2 and SPARX software packages have some GPL dependencies,
# so you are responsible for compliance with the licenses of these packages
# if you opt to use BSD licensing. The warranty disclaimer below holds
# in either instance.
#
# This complete copyright notice must be included in any revised version of the
# source code. Additional authorship citations may be added, but existing
# author citations must be preserved.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or

# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  2111-1307 USA
#
#

import os
from EMAN2 import *
from time import time
	
import matplotlib
matplotlib.use('Agg',warn=False)	 


import matplotlib.pyplot as plt
import sys
import numpy

import math	 
from operator import itemgetter
	 
def main():
	
	progname = os.path.basename(sys.argv[0])
	usage = """WARNING:  **PRELIMINARY** program, still heavily under development. 
				Autoboxes globular particles from tomograms.
				Note that self-generated spherical templates generated by this program
				are 'white'; which means you have to provide the tomogram with 'inverted' (or 'white') contrast, and the same goes for any stacks
				provided (specimen particles, gold, carbon and/or background)."""
			
	parser = EMArgumentParser(usage=usage,version=EMANVERSION)
	
	parser.add_argument("--pad", action='store_true', help="""Provide this if the particles in the --particlestack used to create a template, or the template supplied 
															through --template are in a tight box. The size""",default=False)
	parser.add_argument("--rotationalsearch", action='store_true', help="""At each translation position, vary euler angles as well when searching for particles.""",default=False)
	
	parser.add_argument("--pruneccc", action='store_true', help="""Pruned based on ccc mean and sigma.""",default=False)
	parser.add_argument("--invert", action='store_true', help="""Multiply tomogram subsections by -1 to invert the contrast BEFORE looking for particles.""",default=False)
	parser.add_argument("--normalize", action='store_true', help="""Normalizes the tomogram before looking for particles.""",default=False)
	parser.add_argument("--threshold", action='store_true', help="""Thresholds the tomogram so that all values < 0.0 are made 0 (in the proper contrast, protein is positive).""",default=False)
	#parser.add_argument("--prunerepeated", action='store_true', help="""Prune potential particles that are too close to eachother and thus are likely repeated hits.""",default=False)
	parser.add_argument("--pruneprj", action='store_true', help="""Generate a projection along the z-axis of potential particles, and compare to a projection of the template.""",default=False)
	parser.add_argument("--keep", type=float, help="""Percentage of particles, expressed as a fraction, to keep right before writing the coordinates file and output stack.""",default=0.0)
	parser.add_argument("--keepn", type=int, help="""Total number of particles to keep right before writing the coordinates file and output stack.
													Supersedes --keep""",default=0)
	
	parser.add_argument("--tomogram", type=str, help="Name of the tomogram.",default='')
	parser.add_argument("--goldstack", type=str, help="Name of the stack containing a few gold particles picked from the tomogram.",default=None)
	parser.add_argument("--ptclstack", type=str, help="""Name of the stack containing a few sample particles picked from the tomogram, used to create an initial template.
															with which to search for particles throughout the tomogram.""",default=None)
	
	parser.add_argument("--template", type=str, help="Name of the file containing the template to search for particles throughout the tomogram.",default='')

	parser.add_argument("--backgroundstack", type=str, help="""Name of the stack containing a few boxes picked from regions of the tomogram where there where no particles, 
															no gold, and no carbon.""",default=None)
	parser.add_argument("--carbonstack", type=str, help="Name of the stack containing a few boxes picked from the grid hole (or carbon).",default=None)

	parser.add_argument("--output", type=str, help="Name to output the auto-boxed particles.",default='')
	parser.add_argument("--outputboxsize", type=int, help="Size of the box to put the extracted particles in, and amount by which the subregions will overlap, when searching for particles in the tomogram.", default=0)

	parser.add_argument("--shrink", type=int, help="Integer factor by which the tomogram will be shrunk.", default=0)
	
	parser.add_argument("--subsettrans", type=int, help="Subset of particles to keep/consider after translational alignment.", default=0)
	parser.add_argument("--concentrationfactor", type=int, help="""Determines how many particles will be pre-picked as putative particles. For example, if
																if the tomogram is broken up into subregions of volume V to look for particles in each
																and --concentrationfactor=1, then, the number of best-correlating subvolumes from the subregion
																that will be initially selected as particles will be n=V/(pv*C) where 'pv' is the volume of one particle
																calculated based on the outputboxsize, or the template's boxsize; 'C' is the concentration factor;
																therefore, the largest it is, the fewer particles that will be initially picked.""", default=0)

	parser.add_argument("--apix", type=float, help="The actual apix of the tomogram if for some reason it is wrong on the header.", default=0.0)
	
	parser.add_argument("--ptclradius", type=int, help="The estimated radius of the particle in pixels.", default=0)

	parser.add_argument("--cshrink", type=int, help="""If the tomogram was PREVIOUSLY shrunk, --cshrink is the factor by which the tomogram supplied through --tomogram was shrunk with respect to 
														the raw (unshrunk) tomgoram. This CAN work in conjuction with --shrink, so be careful. If both parameters are specified,
														the coordinates found by the autoboxer will be multiplied by BOTH factors.""", default=0)

	#parser.add_argument("--boxsize", type=int, help="Boxsize to resize the template, either provided through --template or computed from --particlestack", default=1)

	parser.add_argument("--preprocess",type=str,help="Any processor (as in e2proc3d.py) to be applied to the tomogram", default=None)
	parser.add_argument("--lowpass",type=str,help="A lowpass filtering processor (as in e2proc3d.py) be applied to the tomogram", default=None)
	parser.add_argument("--highpass",type=str,help="A highpass filtering processor (as in e2proc3d.py) to be applied to the tomogram.", default=None)
	parser.add_argument("--mask",action='store_true',help="""If provided, a cylindrical mask will be created to mask out the carbon and keep only the grid hole.
															--gridradius and --gridoffest must be specified.""", default=False)
	
	parser.add_argument("--gridradius", type=int, help="Radius of the grid in pixels. Supply this parameter only if also supplying --mask.",default=0)
	parser.add_argument("--gridoffset", type=str, help="""x,y amount of pixels to translate the cylindrical mask if the carbon hole in your tomogram is off center. 
								The left bottom corner would be 0,0. Supply this parameter only if also supplying 
								--mask and the grid hole is not centered in the tomogram.""", default='')
	
	parser.add_argument("--ppid", type=int, help="Set the PID of the parent process, used for cross platform PPID",default=-1)
	parser.add_argument("--verbose", "-v", dest="verbose", action="store", metavar="n",type=int, default=0, help="verbose level [0-9], higner number means higher level of verboseness")
	parser.add_argument("--path",type=str,default=None,help="""Directory to store results in. The default is a numbered series of directories containing the prefix 'sptautobox'; 
															for example, sptautobox_01 will be the directory by default if 'sptautobox' already exists.""")
	
	#parser.add_argument("--yshort",action="store_true",default=False,help="This means you have provided a --tomogram in which 'y' is the short axis.")
	parser.add_argument("--test",action="store_true",default=False,help="This means you have provided a --tomogram in which 'y' is the short axis.")
	parser.add_argument("--templatethreshold",type=float,default=0.0,help="""A binary threshold will be applied to the template which will zero out all the densities below the supplied value, 
												and will make the densities above the supplied value equal to one.""")
	parser.add_argument("--goldthreshtomo",action='store_true',default=False,help="""Zero out all densities above mean of max and min.""")

	global options 
	
	(options, args) = parser.parse_args()
	
	rootpath = os.getcwd()
		
	logger = E2init(sys.argv, options.ppid)
	
	#if not options.template and not options.ptclstack:
	#	print "TERMINATING: You must provide either a template, through --template, or a stack of particles to build one, through --ptclstack."
	#	sys.exit()
	
	print "THE particle radius at reading is!", options.ptclradius
	'''
	Check that the output and tomogam formats are sane, to prevent crashes later.
	'''
	if '.hdf' not in options.output and '.mrc' not in options.output:
		print "ERROR: The output stack must be written to either an mrc or an hdf file."
		sys.exit() 
	
	if '.hdf' not in options.tomogram and '.mrc' not in options.tomogram and '.rec' not in options.tomogram:
			print "ERROR: The tomogram must be in .mrc, .rec (which is also just a .mrc file) or .hdf format."
			
	'''
	Make the directory where to create the database where the results will be stored
	'''
	if options.path and ("/" in options.path or "#" in options.path) :
		print "Path specifier should be the name of a subdirectory to use in the current directory. Neither '/' or '#' can be included. "
		sys.exit(1)

	if not options.path: 
		options.path = "sptAutoBox_01"
	
	files=os.listdir(os.getcwd())
	while options.path in files:
		#path = options.path
		if '_' not in options.path:
			options.path = options.path + '_00'
		else:
			jobtag=''
			components=options.path.split('_')
			if components[-1].isdigit():
				components[-1] = str(int(components[-1])+1).zfill(2)
			else:
				components.append('00')
						
			options.path = '_'.join(components)
			#options.path = path

	if options.path not in files:
		
		os.system('mkdir ' + options.path)	
	
	options.path = rootpath + '/' + options.path

	tomo = EMData(options.tomogram,0)	
	
	if options.apix:
		tomo['apix_x'] = options.apix
		tomo['apix_y'] = options.apix
		tomo['apix_z'] = options.apix

		tomogramfile = options.path + '/' + options.tomogram.split('/')[-1].replace('.','_edED.')
		options.tomogram = tomogramfile

		tomo['origin_x'] = 0
		tomo['origin_y'] = 0
		tomo['origin_z'] = 0

		tomo.write_image(tomogramfile,0)
		tomo = EMData(options.tomogram,0)
	
	'''
	Shrink tomogram (if required), then load it.
	'''
	tomogramfile = options.tomogram
	if options.shrink > 1:
		outputname=''
		if "edED" in options.tomogram:
			outputname=options.tomogram
		else:
			outputname = options.path + '/' + options.tomogram.split('/')[-1].replace('.','_edED.')
		os.system('e2proc3d.py ' + options.tomogram + ' ' + outputname + ' --process=math.meanshrink:n=' + str(options.shrink))
		options.tomogram = outputname
		tomogramfile = options.tomogram
		tomo = EMData(options.tomogram,0)

	tomox = tomo['nx']
	tomoy = tomo['ny']
	tomoz = tomo['nz']
	
	tomogramapix = tomo['apix_x']
	if options.apix:
		tomogramapix = options.apix
	
	yshort=False
	
	print "Before preprocessing, the tomogram is located at", tomogramfile	
	'''
	Apply any specified filters (preprocess, lowpass and/or highpass)
	'''
	
	if options.invert:
		print "Patience. Inverting tomogram's contrast"
		tomogramfile = options.path + '/' + os.path.basename( tomogramfile ).replace('.','_inv.')
		os.system('e2proc3d.py ' + options.tomogram + ' ' + tomogramfile + ' --mult=-1')
		options.tomogram = tomogramfile
		
	if options.preprocess:
		print "Patience. Applying this processor to tomogram:", options.preprocess
		tomogramfile = options.path + '/' + os.path.basename( tomogramfile ).replace('.','_pr.')
		os.system('e2proc3d.py ' + options.tomogram + ' ' + tomogramfile + ' --process=' + options.preprocess)
		options.tomogram = tomogramfile
		
	if options.lowpass:
		print "Patience. Applying lowpass filter to tomogram:", options.lowpass
		print "Whose type is", type(options.lowpass)
		
		#if options.path in tomogramfile:
		#	tomogramfile = tomogramfile.replace('.','_lp.')
		#else:
		tomogramfile = options.path + '/' + os.path.basename( tomogramfile ).replace('.','_lp.')
		os.system('e2proc3d.py ' + options.tomogram + ' ' + tomogramfile + ' --process=' + options.lowpass)
		options.tomogram = tomogramfile

	if options.highpass:
		print "Patience. Applying highpass filter to tomogram:", options.highpass
		
		#if options.path in tomogramfile:
		#	tomogramfile = tomogramfile.replace('.','_hp.')
		#else:
		tomogramfile = options.path + '/' + os.path.basename( tomogramfile ).replace('.','_hp.')
		os.system('e2proc3d.py ' + options.tomogram + ' ' + tomogramfile + ' --process=' + options.highpass)
		options.tomogram = tomogramfile
	
	if options.normalize:	
		print "Patience. Normalizing tomogram."
		tomogramfile = options.path + '/' + os.path.basename( tomogramfile ).replace('.','_norm.')
		os.system('e2proc3d.py ' + options.tomogram + ' ' + tomogramfile + ' --process=normalize')
		options.tomogram = tomogramfile
	
	if options.threshold:	
		print "Patience. Thresholding tomogram."
		tomogramfile = options.path + '/' + os.path.basename( tomogramfile ).replace('.','_thresh.')
		os.system('e2proc3d.py ' + options.tomogram + ' ' + tomogramfile + ' --process=threshold.belowtozero:minval=0.0')
		options.tomogram = tomogramfile

	'''
	Apply any masks if there are big carbon regions beyond the grid-hole and masking is specified.
	'''
	xo=0
	yo=0
	
	if tomo['ny'] < tomo['nz']:
		yshort = True
			
	if options.mask and options.gridradius:
		height = tomoz
		
		'''
		testimage.cylinder only works on cubical boxes. Therefore, make a cubical box to generate the mask.
		'''
		cubem=max(tomox,tomoy,tomoz)
		masksize=cubem
		if options.gridradius*2 > cubem:
			print "Grid radius is larger than the largest tomogram dimension"
			masksize=int(options.gridradius*2)
			print "Therefore, mask size is", masksize		
		
		mask=EMData(masksize,masksize,masksize)
		
		print "I have created the mask box"
		if yshort:
			height = tomoy
		
		mask.to_one()
		print "Mask to one"
		mask.process_inplace('testimage.cylinder',{'radius':options.gridradius,'height':cubem})
		mskfileORIG=options.path + '/mskORIG.rec'
		mask.write_image(mskfileORIG,0)
		if options.gridoffset:
			xo=int(options.gridoffset.split(',')[0])
			yo=int(options.gridoffset.split(',')[-1])
			mask.translate(float(xo),float(yo),0.0)
			mskfileTRANS=options.path + '/mskTRANS.rec'
			mask.write_image(mskfileTRANS,0)
		
		if yshort:
			print "I will rotate the mask"
			yo*=-1
			mask.rotate(0,90,0)
		
		'''
		Then, clip mask to actual tomogram size
		'''
		r = Region(0,0,0, cubem, cubem, tomoz)
		#e = EMData()
		#e.read_image(tomogram,0,False,r)
		
		#r=Region(-tomox/2,-tomoy/2,-tomoz/2,tomox,tomoy,tomoz)
		maskc=mask.get_clip(r)
		
		print "The dimensions of the mask are", mask['nx'],mask['ny'],mask['nz']
		print "The dimensions of the tomogram are", tomox,tomoy,tomoz
	
		tomo.mult(maskc)
		mskfile=options.path + '/mskC.rec'
		maskc.write_image(mskfile,0)
		tomogramfile=options.path + '/' + tomogramfile.split('/')[-1].replace('.','_msk.')
		tomo.write_image(tomogramfile,0)
		options.tomogram=tomogramfile

	'''
	If a template is provided, check that it is sane. If not, fix it.	
	'''
	
	expandedtemplateboxsize=0
	if options.template:
	
		print "You have provided the following template", options.template
		
		if '.hdf' not in options.template and '.pdb' not in options.template and '.mrc' not in options.template:
			print "ERROR: The format of the template to use must be .pdb, .mrc or .hdf"
			sys.exit()
		else:
			check=0
			if '.pdb' in options.template:
				pdbmodel = options.template
				#os.system('cp ' + pdbmodel + ' ' + options.path)
				pdbmodel = pdbmodel.split('/')[-1]
				mrcmodel = pdbmodel.replace('.pdb','.mrc')
				os.system('e2pdb2mrc.py ' + pdbmodel + ' ' + mrcmodel)
				options.template = mrcmodel
				check=1
				if options.verbose:
					print "I've converted the .pdf template to .mrc"
		
			if '.mrc' in options.template and '.hdf' in options.output:
				mrcmodel = options.template
				if check==0:
					#os.system('cp ' + mrcmodel + ' ' + options.path)
					mrcmodel = mrcmodel.split('/')[-1]
				hdfmodel = mrcmodel.replace('.mrc','.hdf')
				os.system('e2proc3d.py ' + mrcmodel + ' ' + hdfmodel + ' && rm ' + mrcmodel)
				options.template = hdfmodel
				check=1
				if options.verbose:
					print "I've converted the .mrc template to .hdf"
		
			template = EMData(options.template,0)
			
			print "I have loaded the template and this is its type:", type(template)
	
			'''
			Make all sides of the template box equally sized and even, if they're not
			'''
			x0 = template['nx']
			y0 = template['ny']
			z0 = template['nz']
			if template['nx'] != template['ny'] or template['nx'] != template['nz'] or template['ny'] != template['nz']:
				side = max(x0,y0,z0)
				
				if options.boxsize:
					side = options.boxsize
				
				elif options.pad:
					side *= 2
				
				if side % 2:
					side += 1
				
				R = Region((x0 - side)/2, (y0 - side)/2, (z0 - side)/2, side, side, side)
				template.clip_inplace(R)
		
				if options.verbose:
					print "I have clipped the template to have a cubical and even-sided box size."
				
				options.template = options.template.replace('.','_fixed.')
				template.write_image(options.path + '/' + options.template,0)
				expandedtemplateboxsize = side
			
			else:
				expandedtemplateboxsize = x0
		
	elif options.ptclstack:
		#ret = generateref(options)
		#options = ret[0]
		#expandedtemplateboxsize = ret[1]
		
		print "\n\n\n\n YOU HAVE PROVIDED A PTCLSTACK!!!!"
		print "\n\n\n"
		ptclhdr = EMData(options.ptclstack,0,True)
		box = ptclhdr['nx']
		outputboxsize = box
		if options.outputboxsize:
			outputboxsize == options.outputboxsize
		
		#genrefpath = options.path + "/genref"
		#os.system('mkdir ' + genrefpath)
		cmd = "cd " + options.path + " && e2spt_classaverage.py --path=genref --input=../" + options.ptclstack + " --output=" + options.ptclstack.replace('.hdf','_ALIavg.hdf') + " --npeakstorefine=10 -v 0 --mask=mask.sharp:outer_radius=-2 --lowpass=filter.lowpass.gauss:cutoff_freq=.04 --align=rotate_translate_3d:search=" +str( int(box/4) ) + ":delta=15:dphi=15:verbose=0 --parallel=thread:7 --ralign=refine_3d_grid:delta=5:range=15:search=2 --averager=mean.tomo --aligncmp=ccc.tomo --raligncmp=ccc.tomo --savesteps --saveali --normproc=normalize.mask --nocenterofmass"
		if options.verbose:
			print "I will generate a template from --particlestack by executing the following command:", cmd
	
		os.system(cmd)
		options.template = options.path + "/genref/" + options.ptclstack.replace('.hdf','_ALIavg.hdf')
		
		
	elif options.outputboxsize:
		outputboxsize = options.outputboxsize
		a = EMData(outputboxsize,outputboxsize,outputboxsize)
		a.to_one()
		a.process_inplace('mask.sharp',{'outer_radius':-2})
		a['apix_x'] = tomogramapix
		a['apix_y'] = tomogramapix
		a['apix_z'] = tomogramapix
		
		if options.ptclradius:
			a.process_inplace('mask.sharp',{'outer_radius':options.ptclradius})
		else:
			print "ERROR: You didn't provide --template or --ptclstack. In the absence of these, you must provide --outputboxsize AND --ptclradius."
			sys.exit()
		
		a.write_image(options.path + '/sph_template.hdf',0)
		#if not options.invert:
		#	a.mult(-1)		
		options.template = options.path + '/sph_template.hdf'
		
	
	else:
		print "ERROR: You didn't provide --template or --ptclstack. In the absence of these, you must provide --outputboxsize."
		sys.exit()
			
	'''
	Scan the tomogram to extract subvolumes to compare against the template
	'''
	x = tomox
	y = tomoy
	z = tomoz
	
	print "!!!!Original tomo dimensions are", x,y,z
	
	print "The template is", options.template
	
	transtemplate = EMData(options.template,0)
	transtemplateapix = transtemplate['apix_x']
	print "With an apix of", transtemplateapix
	
	'''
	Calculate the scale between the reference model and the data, round to the nearest integer to be able to use math.meanshrink (which preserves features),
	then calculate the scale factor again and use xform.scale, to get the exact scaling, even if features might become a bit distorted by xform.scale
	'''	
	meanshrinkfactor = tomogramapix/transtemplateapix
	meanshrinkfactor_int = int(round(meanshrinkfactor))
	#print "The template's apix is", transtemplateapix
	#print "And the tomgoram's apix is", tomogramapix
	#print "Therefore, the meanshrink factor is", meanshrinkfactor
	#print "Which, for the first step of shrinking (using math.meanshrink), will be rounded to", meanshrinkfactor_int
	if meanshrinkfactor_int > 1:
		if options.verbose:
	
			print "About to shrink"
			#print "The type of template is", type(transtemplate)
			print "\n\n\n BBBBBBBB\nANd its boxsize BEFORE shrinking was\nBBBBBBBB\n\n", transtemplate['nx']
		
		transtemplate.process_inplace("math.meanshrink",{"n":meanshrinkfactor_int})
		
		expandedtemplateboxsize = transtemplate['nx']
		#print "\n\n\nCCCCCCCC\nWhereas AFTER shrinking it is\nCCCCCC\n\n", transtemplate['nx']

		#if options.verbose:
		#	print "The template was shrunk, to a first approximation."
		
		transtemplateapix = transtemplate['apix_x']
		
	scalefactor = transtemplateapix/tomogramapix
	expandedtemplateboxsize = round(transtemplate['nx']*scalefactor)
	
	#if options.verbose:
	#print "The finer scale factor to apply is", scalefactor
	
	if float(scalefactor) != 1.0:
		transtemplate.process_inplace("xform.scale",{"scale":scalefactor,"clip":expandedtemplateboxsize})
		expandedtemplateboxsize = transtemplate['nx']
	#transtemplate.process_inplace("xform.scale",{"scale":1,"clip":transtemplatebox})
	
	#print "\n\n\n AAAAAAAAAAAA\n after all necessary APIX MATCHING, the expandedboxsize of the template is", expandedtemplateboxsize
	#print "\n\n\n AAAAAAAAAAAAA\n"
	
	if options.verbose:
		print "The template has now been precisely shrunk."

	'''
	Make a pseudo-spherical or shell-like template with the radius of gyration of the actual template
	for purposes of translational search
	'''
	outputboxsize = expandedtemplateboxsize	
	#ptclradius = round( ( transtemplate['nx'] / 2.0 ) )
	
	if options.outputboxsize:
		outputboxsize = options.outputboxsize
		ptclradius = round( outputboxsize / 2.0 )
		if options.shrink > 1:
			ptclradius = round( ptclradius/ options.shrink )
	
	if options.ptclradius:
		ptclradius = options.ptclradius	
		print "\n\nThe particle radius BEFORE any shrinking is", options.ptclradius	
		if options.shrink > 1:
			ptclradius = round( ptclradius/ options.shrink )
			options.ptclradius = ptclradius
			print "ptclradius being shrunk!!", options.ptclradius
	
	print "\n\n\nRRRRRRRRR\nThe particle radius in pixels is %f \nRRRRRRRRn\n\n" %(ptclradius)
	
	transtemplatename = options.template
	if options.ptclstack:
		transtemplate.process_inplace('mask.sharp',{'outer_radius':ptclradius})
		transtemplate = transtemplate.rotavg_i()
	
		if options.templatethreshold:
			transtemplate.process_inplace('threshold.binary',{'value':options.templatethreshold})
	
		transtemplatename = options.template.split('/')[-1].replace('.','_sphavg.')
		if options.path not in transtemplatename:
			transtemplatename = options.path + '/' + transtemplatename
		transtemplate.write_image(transtemplatename,0)
	
	
	
	regionboxsize = z
	if yshort:
		regionboxsize = y
	
	subcubes = int( (x*y*z) / (regionboxsize*regionboxsize*regionboxsize) )
	
	if options.verbose:
		print "The volume of the tomogram is", x*y*z 
		print "The volume of the subregions is", regionboxsize*regionboxsize*regionboxsize
		print "Therefore, for boxing purposes, the tomogram will be divided into at least these many sections", subcubes
	
	transtemplate.process_inplace('xform.scale',{'scale':1,'clip':regionboxsize})
	#mskrad = ptclboxsiz/2 - 1
	#transtemplate.process_inplace('mask.sharp',{'outer.radius':mskrad})
	transtemplate.write_image(transtemplatename,0)
	zc=regionboxsize/2
	
	expandedtemplateboxsize = regionboxsize
	
	'''
	The tomogram ought to be divided in sub-blocks, which will be cubes with side length equal to the 
	tomogram's thickness (z). When scanning each of these sub-blocks for particles, they need to overlap
	by an amount equal to the box length of the particles (outputboxsize) to ensure picking particles at the edges of each
	sub-block without 'breaking' the particle. 
	The first row and column of sub-blocks need to be centered at boxsize/2.
	All subsequent ones need to be centered at multiples of expandedtemplateboxsize/2 - outputboxsize.
	'''
	
	print "The template has been clipped such that it has a size equal to the short size of the tomogram", expandedtemplateboxsize
	
	if options.verbose:
		print "I will look for subvolumes throughout the tomogram, which has these x, y, z dimensions", x, y, z
		print "Where the boxsize of SUBREGIONS to examine is", regionboxsize
		print "And the outputboxsize of (UNSHRUNK) ptcls to extract is", outputboxsize
	
	if options.shrink > 1:
		expandedtemplateboxsize=expandedtemplateboxsize/2
		print "Because you chose to shrink, the expandedtemplateboxsize for scanning purposes is actually", expandedtemplateboxsize
		print "And therefore, the outputbox (which determines the effective boxisze of the particles in the tomogram DURING scanning, is"
		outputboxsize = outputboxsize / 2
		print outputbox
		
	lines=[]
	
	i=0
	xc = regionboxsize/2
	otherlong = y
	short =z
	if yshort:
		otherlong = z
		short = y
	
	data=[]
	coordset=set()
	ret=None
	
	sbn=0
	zi=0
	
	#print "expandedtemplateboxsize size is", expandedtemplateboxsize
	#print "Therefore its half is", expandedtemplateboxsize/2
	#print "\n\n\n\n@@@@@@@The subregions o the tomogram to scan are THESE!!!!!\n\n"
	boxes=[]
	centers=[]
	xi=0
	xc = regionboxsize/2
	factor=1
	
	#print "\n\n\nFFFFFFFFFFF\n Becuase outputboxsize is", outputboxsize
	#print "And regionboxsize is", regionboxsize
	
	if regionboxsize == outputboxsize:
		factor = regionboxsize / 2
		print "Regionboxsize/2"
	
	elif outputboxsize < regionboxsize/2:
		factor = regionboxsize / 2 + (regionboxsize/2 - outputboxsize)
		print "regionboxsize - outputboxsize"
		
	elif outputboxsize >= regionboxsize/2 and outputboxsize < regionboxsize:
		factor = regionboxsize/2 + (regionboxsize/2 - outputboxsize/2)
		print "outputboxsize/2"
	
	print "\n\n\nFFFFFFF\nFactor is",factor
	print "\nFFFFFFFFFFFFF\n\n\n\n"
	
	coordsset = set()
	coeffset = set()
	rmsdset = set()
	
	count=0
	finalx=0
	while xi < x and xc <= x -regionboxsize/2 and finalx < 2:
		yi=0
		yc = regionboxsize/2
		#print "xi is", xi
		finaly=0		
		while yi < y and yc <= y -regionboxsize/2 and finaly < 2:
			zi=0
			zc = regionboxsize/2
		#	print "yi is", xi
			while zi < z and zc <= z -regionboxsize/2:
				#print "zi is", xi
				#print "Therefore the initial box coords is", xi,yi,zi
				box=[xi,yi,zi, xi+regionboxsize , yi+regionboxsize , zi+regionboxsize]
				center=[xc,yc,zc]
				boxes.append(box)
				centers.append(center)
				
				if options.mask and options.gridradius:
					print "Because mask is on, I will go to the scanner considering that!"
					criteria=(xc - (xo + x) )*(xc - (xo + x)) + (yc - (yo + y))*(yc - (yo + y))
					print "Criteria is", criteria
					print "And must be less than grdiradius squared which is", options.gridradius * options.gridradius
					if (xc - (xo + x) )*(xc - (xo + x)) + (yc - (yo + y))*(yc - (yo + y)) < options.gridradius * options.gridradius:
						print "The center of the subox is inside the mask"
						ret = scanposition(options,transtemplate,outputboxsize,yshort,xi,yi,zi,xc,yc,zc,sbn,x,y,xo,yo,count)
				else:
					ret = scanposition(options,transtemplate,outputboxsize,yshort,xi,yi,zi,xc,yc,zc,sbn,x,y,xo,yo,count)
				
				if ret:
					#print "These many particles have been returned", len(ret)
					asdfg=0
					for r in ret:
						#print "I will examine particle", asdfg, r
						#print "This info has been returned", r
						newcoeff = r[0]
						newcoefftuple = tuple( [newcoeff] )
						coords=tuple( [ r[1],r[2],r[3] ] )
						#oldcoeff=0
						
						if coords in coordset:
							#print "The particle was already in coordset see", coordset							
							for kkk in range(len(data)):
								if list(coords) in data[kkk]:
									oldcoeff = data[kkk][0]
									if oldcoeff < newcoeff:
										data[kkk][0]=newcoeff
										#print "The particlce was already in data, but the newcoeff is higher than the old", oldcoeff, newcoeff
										
						elif coords not in coordset:
								
							coordset.add(coords)
							coeffset.add(newcoefftuple)
							data.append( (newcoeff, int(round(coords[0])), int(round(coords[1])), int(round(coords[2])) ) )
							#print "I have appended a new particle!", [newcoeff,coords]
							count+=1
						asdfg+=1
							
				#print "And I have indeed appended such box", box
				sbn+=1
				#zi = zi + (factor + regionboxsize - outputboxsize)
				#zc = zc + (factor + regionboxsize - outputboxsize)	
				zi += factor
				zc += factor
			#yi = yi + (factor + regionboxsize - outputboxsize)
			#yc = yc + ( factor + regionboxsize - outputboxsize)
			yi += factor
			yc += factor
			if yi > y or yc > (y - regionboxsize/2 ) and y % factor:
				#print "I am at a special last box in Y! Therefore the old yi and yc", yi, yc 
				yi = y - regionboxsize
				yc = y - regionboxsize/2
				#print "will be changed for", yi, yc
				finaly+=1
			
			if options.test:
				yi*=2
				yc*=2

		#xi = xi + ( factor + regionboxsize - outputboxsize )
		#xc = xc + ( factor + regionboxsize - outputboxsize )
		xi += factor
		xc += factor
		if xi > x or xc > y - regionboxsize/2 and x % factor:
			#print "I am at a special last box in X! Therefore the old xi and xc", xi, xc 
			xi = x - regionboxsize
			xc = x - regionboxsize/2
			#print "will be changed for", xi, xc
			finalx+=1

		if options.test:
			xi*=2
			xc*=2
	print "\n\nCCCCCCCCCCCC\nThe total number of appended particles was %d\nCCCCCCCCCC\n\n" %(count)
	#for m in range(len(boxes)):
	#	print 'box', boxes[m]
	#	print '\t center', centers[m]
	
	data=set(data)
	data=list(data)
	data.sort()
	data.reverse()
	
	data=list(rmsdprune(data,options))
	
	
	data=sorted(data, key=itemgetter(1,2,3))
	
	print "rmsd round one DATA IS"
	for d in data:
		print d
		
	
	#for i in data:
	#	print "This is in data", i

	print "The len of data BEFORE ANY PRUNNING, except first round of rmsd IS", len(data)
	
	setdata = set()
	for d in data:
		if (d[0],d[1],d[2],d[3]) not in setdata:
			setdata.add( (d[0],d[1],d[2],d[3]) )	
		else:
			print "repeated particle when prunning by set data!"
	
	data=list(setdata)
	print "after set prunning by set, len data is", len(data)
	
	lendata1=len(data)
	if options.backgroundstack:
		print "BG Stack to send is", options.backgroundstack
		ret = meancalc(options,options.backgroundstack)
		tag='background'
		data = pruner(data,tag,ret[0],ret[1],ret[2],ret[3])
		
		lendata2=len(data)
		pruned= lendata1-lendata2
		print "These many particles were pruned using the background stack",pruned
	
	lendata1=len(data)
	if options.carbonstack:
		print "CARBON Stack to send is", options.carbonstack
		ret = meancalc(options,options.carbonstack)
		tag='carbon'
		data = pruner(data,tag,ret[0],ret[1],ret[2],ret[3])
		
		lendata2=len(data)
		pruned= lendata1-lendata2
		print "These many particles were pruned using the carbon stack",pruned
	
	lendata1=len(data)
	if options.goldstack:
		print "GOLD Stack to send is", options.goldstack
		ret = meancalc(options,options.goldstack)
		tag='gold'
		data = pruner(data,tag,ret[0],ret[1],ret[2],ret[3])
		
		lendata2=len(data)
		pruned= lendata1-lendata2
		print "These many particles were pruned using the gold stack",pruned
	
	print "The len of data AFTER prunnin using stacks is", len(data)
	
	if options.pruneccc:
	
		coeffs = []
		for d in range(len(data)):
			coeffs.append(data[0])
		
		coeffsmean = numpy.mean(coeffs, dtype=numpy.float64)	
		coeffssigma = numpy.std(coeffs, dtype=numpy.float64)
		
		#print "Coeffs are", coeffs
		print "These many ptcls before ccc pruning", len(data)
		ncoeffs = len(coeffs)
		topncoeffs = int(ncoeffs*(0.05))
		print "Therefore, 5% are", topncoeffs
		topcoeffs = coeffs[:topncoeffs]
		bottomcoeffs = coeffs[topncoeffs:]
		print "The top coeffs are", topcoeffs
		print "And the len of bottom coeffs are", len(bottomcoeffs)
		
		print "The sum of bottom and top coeffs should equal the len of data", len(data), len(topcoeffs) + len(bottomcoeffs)
		
		print "\n\n\n\nThe mean and sigma of the datas CCC", coeffsmean, coeffssigma
		print "\n\n\n\nWhereas the max and the min of the data's ccc are CCC", numpy.max(coeffs), numpy.min(coeffs)
		print "\n\n\n\n"
		lowerbound = coeffsmean
		#upperbound = coeffsmean + coeffssigma * 1.0
		upperbound = numpy.max(coeffs)
		#print "Therefore, one sigma away, the lower and upper bounds are", lowerbound, upperbound
	
		removed_count=0
		conserved_count=0
		
		pruneddata = []
		print "Will now do correlation coefficient based pruning"	
		for d in data:
			#print "The data element to examine", d
			coeff = d[0]
			#print "This is the coeff to examine", coeff
			if coeff < lowerbound or coeff > upperbound:
				removed_count+=1
				data.remove(d)
				coeffs.remove(coeff)
				print "One element was removed because it has coeff < lowerbound or coeff > upperbound", coeff, lowerbound, upperbound
			elif coeff in coeffs and coeff in bottomcoeffs:
				coeffs.remove(coeff)
				data.remove(d)
				removed_count+=1
				print "Element removed because coeff was in bottomcoeffs", coeff
			elif coeff in coeffs and coeff not in topcoeffs:
				coeffs.remove(coeff)
				data.remove(d)
				removed_count+=1
				print "Element removed because coeff was in top coeff", coeff
			else:
				conserved_count+=1
				print "not removed", coeff
				if d not in pruneddata:
					pruneddata.append(d)
			print "removed count", removed_count
			print "preserved count", conserved_count
	
		print "I have pruned out these many based on mean and sigma statistics", count
		print "And therefore data now is", len(data)
		print "But pruned data is more accurately", len(pruneddata)
		
		data = pruneddata
	
		print "THe len of data AFTER CCC pruning is", len(data)
	
	if options.pruneprj:
		print "I will do projection based pruning"
		bxf = options.outputboxsize
		tempcrop = transtemplate.copy()
	
		bxi=tempcrop['nx']
		byi=tempcrop['ny']
		bzi=tempcrop['nz']
		xct=bxi/2
		yct=byi/2
		zct=bzi/2
	
		r=Region( (2*xct - bxf)/2, (2*yct - bxf)/2, (2*zct - bxf)/2, bxf,bxf,bxf)	

		tempcrop.clip_inplace(r)
		#print "THe copy if the template has this mean and max and size", tempcrop['mean'], tempcrop['maximum'], tempcrop['nx']

		tempcrop.write_image(options.path + '/' + 'tempcrop.hdf',0)
		
		t = Transform({'type':'eman','az':0,'alt':0,'phi':0})	
		tprj = tempcrop.project("standard",t)
		tprj.set_attr('xform.projection',t)
		tprj['apix_x'] = tempcrop['apix_x']
		tprj['apix_y'] = tempcrop['apix_x']
		tprj.write_image(options.path + '/' + 'tprj.hdf',0)
		
		prjccfs = []
		newdata=[]
		kkk=0
		basicdata=set()
		tside = Transform({'type':'eman','az':0,'alt':-90,'phi':0})
		for d in data:
			#print "d in data is", d
			#print "d[1] is ", d[1]
			x=d[1]
			y=d[2]
			z=d[3]
			#print "The actual coordinates used for extraction are", x, y, z
			r = Region((2*x- options.outputboxsize)/2,(2*y-options.outputboxsize)/2, (2*z-options.outputboxsize)/2, options.outputboxsize, options.outputboxsize, options.outputboxsize)
			e = EMData()
			e.read_image(options.tomogram,0,False,r)
			
			#print "dimensions of read e are", e['nx'],e['ny'],e['nz']
			eb = e['nx']
			mask=EMData(eb,eb,eb)
			mask.to_one()
			mask.process_inplace('mask.sharp',{'outer_radius':-2})
			e.process_inplace('normalize.mask',{'mask':mask})
			#e.process_inplace('mask.sharp',{'outer_radius':-2})
			
			e.mult(mask)
			
			#print "After normalization in 3D and masking, mean and mean nonzero are", e['mean'],e['mean_nonzero']
			
			#print "I have masked e, its mean, meannonzero, min and max are", e['mean'], e['mean_nonzero'],e['minimum'],e['maximum']
			#e.process_inplace('normalize.edgemean')
			pprj=e.project("standard",t)
			
			#if kkk==0:
			#	display(pprj)
			
			mask2d=EMData(eb,eb)
			mask2d.to_one()
			mask2d.process_inplace('mask.sharp',{'outer_radius':-2})
			pprj.process_inplace('normalize.mask',{'mask':mask2d})
			
			#pprj.process_inpace('normalize')
			#pprj.process_inplace('mask.sharp',{'outer_radius':-2})
			pprj.mult(mask2d)
			
			#if kkk==0:
			#	display(pprj)
			#pprj.process_inplace('mask.sharp',{'outer_radius':-2})
			
			#print "After FIRST normalization in 2D and masking, mean and mean nonzero are", pprj['mean'],pprj['mean_nonzero']
			
			#if kkk==0:
			#	display(pprj)
				
			#print "I have projected, masked, normalized and remasked e, whose mean, meannonzero, min, max are", pprj['mean'], pprj['mean_nonzero'],pprj['minimum'], pprj['maximum']
			pprj['apix_x'] = e['apix_x']
			pprj['apix_y'] = e['apix_x']
			pprj.write_image(options.path + '/' + 'pprj.hdf',kkk)
			
		
			#pprj.process_inplace('normalize.edgemean')
			
			#print "The template prj has a size of", tprj['nx'],tprj['ny']
			#print "The particle prj has a size of", pprj['nx'],pprj['ny']
			ccf = tprj.calc_ccf(pprj)
			ccf.process_inplace("xform.phaseorigin.tocorner") 
			ccf.process_inplace('normalize')
			
			locmax = ccf.calc_max_location()
									
			locmaxX = locmax[0]
			locmaxY = locmax[1]
			
			#print "\nThe peak is at", locmaxX, locmaxY
			
			transx = bxf/2 - locmaxX
			transy = bxf/2 - locmaxY
			
			#print "\nAnd the proposed translations are", transx,transy
			
			x=x+transx
			y=y+transy
			
			
			'''
			Generate side projections to center Z
			'''
			pprjside=e.project('standard',tside)
			pprjside.process_inplace('normalize.mask',{'mask':mask2d})
			pprjside.mult(mask2d)
			pprjside.process_inplace('mask.sharp',{'outer_radius':-2})
			
			pprjside['apix_x'] = e['apix_x']
			pprjside['apix_y'] = e['apix_x']
			pprjside.write_image(options.path + '/' + 'pprjside.hdf',kkk)
			
			ccfside = tprj.calc_ccf(pprjside)
			ccfside.process_inplace("xform.phaseorigin.tocorner") 
			ccfside.process_inplace('normalize')
			
			locmaxside = ccfside.calc_max_location()
									
			locmaxXside = locmaxside[0]
			locmaxZside = locmaxside[1]
			
			transz = bxf/2 - locmaxZside
			#print "Transz is", transz
			z=z-transz
			
			
			
			#newcoords=(x,y,z)
			newccf = ccf['maximum']
			#print "\nThe ccf for this projection is", newccf
			#print "\nTherefore, the new coordinates are", x,y
			
			prjccfs.append(newccf)
			
			#coordset.add(coords)
			#coeffset.add(newcoefftuple)
			
			if (newccf,x,y,z) not in basicdata:
				basicdata.add( (newccf,x,y,z) )		
				
				newdata.append( [newccf,x,y,z] )
			
				r = Region((2*x- options.outputboxsize)/2,(2*y-options.outputboxsize)/2, (2*z-options.outputboxsize)/2, options.outputboxsize, options.outputboxsize, options.outputboxsize)
				e = EMData()
				e.read_image(options.tomogram,0,False,r)
			
				eb = e['nx']
				mask=EMData(eb,eb,eb)
				mask.to_one()
				mask.process_inplace('mask.sharp',{'outer_radius':-2})
				e.process_inplace('normalize.mask',{'mask':mask})
				e.mult(mask)
			
				pprj=e.project("standard",t)
				pprj['apix_x'] = e['apix_x']
				pprj['apix_y'] = e['apix_x']
				pprj.write_image(options.path + '/' + 'pprj_corrected.hdf',kkk)
			
			
				pprjside=e.project("standard",tside)
				pprjside['apix_x'] = e['apix_x']
				pprjside['apix_y'] = e['apix_x']
				pprjside.write_image(options.path + '/' + 'pprj_correctedside.hdf',kkk)
			
			
				kkk+=1
			else:
				print "TRying to add repeated particle in FIRST PRJ loop!"
			newdata.sort()
		
		#print "\n\n\nsorted newdata are", newdata
		newdata.reverse()
		#print "\n\n\nreversed", newdata 
		
		
		setdata = set()
		lll=0
		for d in newdata:
			if (d[0],d[1],d[2],d[3]) not in setdata:
				setdata.add( (d[0],d[1],d[2],d[3]) )	
		else:
			lll+=1
		
		print "repeated particles when prunning by FIRST PRJ prune!",lll
		
		newdata = list(setdata)
		print "Therefore data len is now", len(newdata)
		
		
		newdata=sorted(newdata, key=itemgetter(1,2,3))
		
		
		
		mmm=0
		ppp=0
		#prjs=[]
		#means=[]
		#sigmas=[]
		maxs2d=[]
		#mins2d=[]
		
		newestdata = []
		rrr=0
		basicdata=set()
		for d in newdata:
			x=d[1]
			y=d[2]
			z=d[3]
			r = Region((2*x- options.outputboxsize)/2,(2*y-options.outputboxsize)/2, (2*z-options.outputboxsize)/2, options.outputboxsize, options.outputboxsize, options.outputboxsize)
			e = EMData()
			e.read_image(options.tomogram,0,False,r)
			
			eb = e['nx']
			mask=EMData(eb,eb,eb)
			mask.to_one()
			mask.process_inplace('mask.sharp',{'outer_radius':-2})
			e.process_inplace('normalize.mask',{'mask':mask})
			e.mult(mask)
			
			pprj=e.project("standard",t)
			pprj['apix_x'] = e['apix_x']
			pprj['apix_y'] = e['apix_x']
			pprj.write_image(options.path + '/' + 'pprj_corrected_sorted.hdf',mmm)
			
			pmx=pprj.process('xform.mirror',{'axis':'x'})
			pmy=pprj.process('xform.mirror',{'axis':'y'})
			
			ccfpmx=pprj.calc_ccf(pmx)
			ccfpmy=pprj.calc_ccf(pmy)
			
			ccfpmxC=ccfpmx.process('xform.phaseorigin.tocorner')
			ccfpmyC=ccfpmy.process('xform.phaseorigin.tocorner')
			
			maxccfpmxC=ccfpmxC.calc_max_location()
			maxccfpmyC=ccfpmyC.calc_max_location()
			
			xt=(eb/2.0 - maxccfpmxC[0])/2.0
			yt=(eb/2.0 - maxccfpmyC[1])/2.0

			pfix=pprj.copy()
			pfix.translate( xt, yt, 0)
			
			newx=x+xt
			newy=y+yt
			
			'''
			Generate side projections to center Z
			'''
			pprjside=e.project("standard",tside)
			pprjside['apix_x'] = e['apix_x']
			pprjside['apix_y'] = e['apix_y']
			pprjside.write_image(options.path + '/' + 'pprj_corrected_sorted_side.hdf',mmm)
			
			pmxside=pprjside.process('xform.mirror',{'axis':'x'})
			pmzside=pprjside.process('xform.mirror',{'axis':'y'})
			
			ccfpmxside=pprjside.calc_ccf(pmxside)
			ccfpmzside=pprjside.calc_ccf(pmzside)
			
			ccfpmxCside=ccfpmxside.process('xform.phaseorigin.tocorner')
			ccfpmzCside=ccfpmzside.process('xform.phaseorigin.tocorner')
			
			maxccfpmxCside=ccfpmxCside.calc_max_location()
			maxccfpmzCside=ccfpmzCside.calc_max_location()
			
			#xtside=(eb/2.0 - maxccfpmxCside[0])/2.0
			ztside=(eb/2.0 - maxccfpmzCside[1])/2.0
			#print "zt side is", ztside
			pfixside=pprjside.copy()
			pfixside.translate( 0, 0, ztside)
			
			#newx=x+xt
			newz=z-ztside
			
			if math.fabs(xt) <= eb/8.0 and math.fabs(yt) <= eb/8.0 :
				#newestcoords=(newx,newy,newz)
				
				newestccf = ccfpmy['maximum']
				if ccfpmx['maximum'] > ccfpmy['maximum']:
					newestccf = ccfpmx['maximum']
				
				#print "\n$$$$$$$$$$$$$$$$\nAUTOCORRELATION PARTICLE WRITTEN!\n"
			
				#prjccfs.append(newccf)
			
				#coordset.add(coords)
				#coeffset.add(newcoefftuple)
				#newestdata.append( [newestccf,newestcoords] )
				
				r = Region((2*newx- options.outputboxsize)/2,(2*newy-options.outputboxsize)/2, (2*newz-options.outputboxsize)/2, options.outputboxsize, options.outputboxsize, options.outputboxsize)
				e = EMData()
				e.read_image(options.tomogram,0,False,r)
			
				eb = e['nx']
				mask=EMData(eb,eb,eb)
				mask.to_one()
				mask.process_inplace('mask.sharp',{'outer_radius':-2})
				e.process_inplace('normalize.mask',{'mask':mask})
				e.mult(mask)
			
				pprj=e.project("standard",t)
				pprj['apix_x'] = e['apix_x']
				pprj['apix_y'] = e['apix_x']
				pprj.write_image(options.path + '/' + 'pprj_corrected_sorted_autocorrelated.hdf',ppp)	
								
				mean=pprj['mean_nonzero']
				#means.append(mean)
				#print "The mean_nonzero is %f, compared to mean %f" %( mean, pprj['mean'] )
			
				sigma=pprj['sigma_nonzero']
				#sigmas.append(sigma)
			
				max=pprj['maximum']
				maxs2d.append(max)
			
				min=pprj['minimum']
				#mins2d.append(min)
				if (newestccf,newx,newy,newz) not in basicdata:			
					newestdata.append([newestccf,newx,newy,newz,ppp,max,min,sigma,mean,pprj])
					basicdata.add( (newestccf,newx,newy,newz) )
					ppp+=1
				else:
					print "TRYing to add repeated particle in second PRJ loop!"	
				
			else:
				rrr+=1
				#print "\nParticle eliminated because translation from AUTOCORRELATION were too big!\n"
				pass
			mmm+=1
			#if d[0] < prjccfs_mean - prjccfs_sigma:
			#	newdata.remove(d)
			#	print "I have removed a particle based new PRJ mask"
	
		print "The number of particles pruned by AUTOCORRELATION is", rrr		
		print "Therefore, AFTER AUTUCORRELATION prunning, the len of data is", len(newestdata)
		
		
		#setdata = set()
		#lll=0
		#for d in newestdata:
		#	if (d[0],d[1],d[2],d[3]) not in setdata:
		#		setdata.add( (d[0],d[1],d[2],d[3]) )	
		#else:
		#	lll+=1
		
		#print "repeated particles when prunning by SECOND PRJ prune!",lll
		
		#newestdata = list(setdata)
		#print "Therefore data len is now", len(newestdata)
		
				
		newestdata=sorted(newestdata, key=itemgetter(1,2,3))
		
		#print "DATA IS"
		#for d in newestdata:
		#	print d
		
		
		'''
		MAX based prunning, intended to further get rid of golds
		'''
		MAXSmean = numpy.mean(maxs2d,dtype=numpy.float64)
		MAXSsigma = numpy.std(maxs2d,dtype=numpy.float64)

		print "The mean of MAXS", MAXSmean
		print "The sgima of MAXS", MAXSsigma
		print "\n"
		
		maxs_thresh = MAXSmean + 2*MAXSsigma
		print "Because MAXSmean is %f and MAXSsigma is %f then maxs_thresh = MAXSmean + 2*MAXSsigma is %f" %(MAXSmean, MAXSsigma, maxs_thresh)
		
		co=0
		for d in newestdata:
			#print "Len d is", len(d)
			if len(d) < 10:
				print "Aberrant len detected! d is", d
				
				sys.exit()
			bad=0
			tempprj=d[-1]
			newprj=tempprj.copy()
			for i in range(3):
				#if d[-5] > maxs_thresh:
				max=newprj['maximum']
				if max > maxs_thresh:
					#print "A particle has been removed because its max %f is larger maxs_thresh %f based on PRJ" %(d[-5],maxs_thresh)
					loc=newprj.calc_max_location()
					newprj.set_value_at(loc[0],loc[1],0.0)
					bad+=1
			if bad > 2:
				newestdata.remove(d)
				co+=1
		
		print "These many particles were removed based on max value", co
		print "Len data after max prunning is", len(newestdata)
		
		'''
		MIN based prunning (not clear so far that min info can be used to prune in addition to max prunning)
		'''
		
		newmins=[]
		for d in newestdata:
			newmins.append(d[-4])
			
		MINSmean = numpy.mean(newmins,dtype=numpy.float64)
		MINSsigma = numpy.std(newmins,dtype=numpy.float64)
		
		print "The mean of MINS", MINSmean
		print "The sgima of MINS", MINSsigma
		print "\n"
	
	
		'''
		SIGMA based prunning; noise has a smaller std than noise + data; and gold + data has a much larger std
		'''
		
		newsigmas=[]
		for d in newestdata:
			newsigmas.append(d[-3])
			
		SIGMASmean = numpy.mean(newsigmas,dtype=numpy.float64)
		SIGMASsigma = numpy.std(newsigmas,dtype=numpy.float64)
		
		print "The mean of SIGMAS", SIGMASmean
		print "The sgima of SIGMAS", SIGMASsigma
		print "\n"
		
		sigmas_thresh_upper = SIGMASmean + 2*SIGMASsigma
		sigmas_thresh_lower = SIGMASmean - 2*SIGMASsigma
		print "Because SIGMASmean is %f and SIGMASsigma is %f then sgimas_thresh_upper and lower are %f, %f" %(SIGMASmean, SIGMASsigma, sigmas_thresh_upper, sigmas_thresh_lower)
		
		co=0
		for d in newestdata:
			if d[-3] > sigmas_thresh_upper or d[-3] < sigmas_thresh_lower:
				#print "A particle has been removed because its sgima is larger or smaller than mean_thresh based on PRJ"
				newestdata.remove(d)
				co+=1
		print "These many particles were removed based on sigma prunning", co
		print "Len data after sigma prunning is", len(newestdata)

		
		'''
		MEAN based prunning; noise has a mean closer to zero than noise + data
		'''
		
		newmeans=[]
		for d in newestdata:
			newmeans.append(d[-2])
		
		MEANSmean = numpy.mean(newmeans,dtype=numpy.float64)
		MEANSsigma = numpy.std(newmeans,dtype=numpy.float64)

		print "\nThe mean of MEANS is", MEANSmean
		print "The sigma of MEANS is", MEANSsigma
		
		means_thresh_lower = MEANSmean - 2*MEANSsigma
		means_thresh_upper = MEANSmean + 2*MEANSsigma

		#print "Because MEANSmean is %f and MEANSsigma is %f then means_thresh_lower = MEANSmean - MEANSsigma is %f, and means_thresh_upper = MEANSmean - MEANSsigma is %f " %(MEANSmean, MEANSsigma, means_thresh_lower, means_thresh_upper)
		
		#co=0
		#for d in newestdata:
		#	if d[-2] > means_thresh_upper or d[-2] < means_thresh_lower:
		#		#print "A particle has been removed because its mean is larger or smaller than mean_thresh_upper or mean_thresh_lower based on PRJ"
		#		newestdata.remove(d)
		#		co+=1
		#print "These many particles were removed based on mean prunning", co
		
		
		print "Final data to consider after all special prunnings is this long", len(newestdata)	
		
		finaldata = set()
		nnn=0
		repeat=0
		for d in newestdata:
			if (d[0],d[1],d[2],d[3]) not in finaldata:
				finaldata.add( (d[0],d[1],d[2],d[3]) )
				fpprj=d[-1]	
				fpprj.write_image(options.path + '/' + 'pprj_corrected_sorted_pruned.hdf',nnn)
				nnn+=1
			else:
				repeat+=1
				
		data=finaldata
		print "\nYet, I found these many repeated particles, who knows from where", repeat
		
		print "\nTHe total number of particles in the SET data should be", nnn
		print "lets see", len (data)
				

	'''
	Prune particles based on correlation. Peaks in correlation should be representative of particles, and only N of those
	peaks are kept for non-overlapping boxes when scanning sub-regions of the tomogram, based on --concentrationfactor .
	These can be further pruned by eliminating particles that deviate a lot from the mean correlation of the selected peaks.
	'''
	
	if options.subsettrans:
		data = data[0:options.subsettrans]
		print "I Have taken a subset of the data, see", options.subsettrans, len(data)
		
		#print "The sorted subset of data is", data
	
	
	#if options.prunerepeated:
	#print "I will now see if there are repeated elements"
	#data=rmsdprune(data,options)
	#print "Data after FIRST rmsd prune has these many elements", len(data)
	#print "And each element has these many subelements", len(data[0])
	data=sorted(data, key=itemgetter(1,2,3))
	print "After RMSD prune, data len is", len(data)
	
	data=list(rmsdprune(data,options))
	
	if options.keep and not options.keepn:
		print "I will keep these many particles based on --keep", options.keep 
		upperlim = round( len(data)*options.keep )
		data = data[:upperlim]	
	
	if options.keepn:
		print "I will keep these many particles based on --keepn", options.keepn 
		data = data[:options.keepn]	
	
	if options.verbose:
		print "The program has finished scanning the tomogram for subvolumes"
		
	
	
	
	
	
	coords=set()	
	for i in data:
		#print "The data element to get coords is", data
		x=round(i[1])
		y=round(i[2])
		z=round(i[3])
		c=(x,y,z)
		if c not in coords:
			coords.add(c)
		#print "Therefore coords are", (x,y,z)
	
	coords=set(coords)
	coords=list(coords)
	coords=sorted(coords, key=itemgetter(0,1,2))
	
	print "The sorted coords are",
	for c in coords:
		print c
	
	for c in coords:
		x=c[0]
		y=c[1]
		z=c[2]
		line = str(x) + ' ' + str(y) + ' ' + str(z) + '\n'
		if options.shrink > 1:
			line = str(x * options.shrink) + ' ' + str(y * options.shrink) + ' ' + str(z * options.shrink) + '\n'
		if options.cshrink > 1:
			line = str(x * options.cshrink) + ' ' + str(y * options.cshrink) + ' ' + str(z * options.cshrink) + '\n'	
		#if options.verbose > 3:
		#	print ''
			#print "I have found a particle at these coordinates %s, and with this coefficient %f" %( line, i[0] )
		lines.append(line)
		
	print "Coordinates for THESE many FINAL particles were written", len(coords) 
	coordsname = options.output.replace('.mrc','_coords.txt')
	coordsname = options.output.replace('.hdf','_coords.txt')
	coordsname = options.path + '/' + coordsname
	f = open(coordsname,'w')
	f.writelines(lines)
	f.close()
	
	if options.verbose:
		print "I have written the coordinates to the following file", coordsname 

	return()




def rmsdprune(data,options):		
	elementstoremove = set()
	data=list(data)
	for d in range(len(data)):
		dvector = numpy.array( [ data[d][1],data[d][2],data[d][3] ] )
		dcoeff = data[d][0]
		#print"This is the d vector and its coeff", dvector, dcoeff
		for e in range(d+1,len(data)):
			evector = numpy.array( [ data[e][1],data[e][2],data[e][3] ] )
			ecoeff = data[e][0]
			#if options.verbose:
				#print ''
				#print "The elements to compare are", dvector,evector
				#print "Their coeffs are", dcoeff, ecoeff
								
			angle = numpy.degrees( numpy.arccos( numpy.dot(dvector,evector) / ( numpy.dot(evector,evector) * numpy.dot(dvector,dvector) ) ))
			rmsd = numpy.linalg.norm(dvector - evector)
			#print "Their rmsd is", rmsd
			
			if float(rmsd) < float(options.ptclradius*2.0 - 2):
				#print "\nPPPPPPPP\n The particle is too close to another one or was already picked!!! evec=%s, dvec=%s,rmsd=%f \nPPPPPPPP\n" %(evector,dvector,rmsd)
				#pp = 1
				#print "And PP is ", pp
				#if rmsd < ptclradius:
					#print "In fact, they seem to overlap at least in half of their volume; these are their coordinates", elementvector, newvector
					#print "And PP is ", pp
					#if rmsd == 0:
					#	print ''
				
				#print "which is lower than ptclradius*2, see", ptclradius*2	
				#print "Actually; the coordinates for their center are identical, and therefore this is a repeated particle", elementvector, newvector
				#print "And PP is ", pp
				if dcoeff > ecoeff:
					if data[e] not in elementstoremove:
						pass
						#print "I will remove this element", data[e]
						#print "Becauase its rmsd is", rmsd
						#print "And particle radius, supposedly is", options.ptclradius
						#print "Therefore, the threshold is anything lower than twice that will be removed",float(options.ptclradius*2.0)
						#print "since evector has the lowest coeff, it will be added to elementstoremove", data[e]
						#elementstoremove.append(data[e])
					elementstoremove.add(data[e])
				elif ecoeff > dcoeff:
					if data[d] not in elementstoremove:
						pass
						#print "I will remove this element", data[d]
						#print "Becauase its rmsd is", rmsd
						#print "since dvector has the lowest coeff, it will be added to elementstoremove", data[d]
						#elementstoremove.append(data[d])
					elementstoremove.add(data[d])

	#print "\nThese are the elements to remove", elementstoremove
	#print "\nFrom this data", data			
	#print "\n"
	print "Inside the FUNCTION RMSDPRUNE, this is data len", len(data)
	print "The number of elements to remove is", len(elementstoremove)
	for ele in elementstoremove:
		if ele in data:
			
			data.remove(ele)
			#print "Therefore data now is", data
	#print "\n\nEEEEEEE\nBut I have removed these many REPEATED elements%d\nEEEEEEEE\n\n" %( len(elementstoremove))							
	print "Therefore the len of data tu RETRURN FROM rmsdpruner is", len(data)
	data=set(data)
	print "When turned to a set has this len", len(data)
	return(data)




def meancalc(options,stack,normalize=False):
	print "Stack RECEIVED in meancalc is", stack
	n=EMUtil.get_image_count(stack)
	#print "N is", n
	means=[]
	maxs=[]
	mins=[]
	
	for i in range(n):
		a=EMData(stack,i,True)
		if normalize:
			a=EMData(stack,i)
			bx=a['nx']
			mask = EMData(bx,bx,bx)
			mask.to_one()
			mask.process_inplace('mask.sharp',{'outer_radius':-2})
			a.process_inplace('normalize.mask',{'mask':mask})		
			a.mult(mask) #NEW
			
		meana=a['mean']
		means.append(meana)
		
		max=a['maximum']
		maxs.append(max)
		
		min=a['minimum']
		mins.append(min)
	
	mean=numpy.mean(means, dtype=numpy.float64)
	sigma_mean=numpy.std(means, dtype=numpy.float64)
	
	mean_maxs=numpy.mean(maxs, dtype=numpy.float64)
	sigma_maxs=numpy.std(maxs, dtype=numpy.float64)
	
	mean_mins=numpy.mean(mins, dtype=numpy.float64)
	sigma_mins=numpy.std(mins, dtype=numpy.float64)
	
	return (mean_maxs,sigma_maxs,mean_mins,sigma_mins,mean,sigma_mean)
	
	
def pruner(data,tag,mean_maxs,sigma_maxs,mean_mins,sigma_mins):	
	data=list(data)
	for d in data:
		#print "d in data is", d
		#print "d[1] is ", d[1]
		x=d[1]
		y=d[2]
		z=d[3]
		#print "The actual coordinates used for extraction are", x, y, z
		r = Region((2*x- options.outputboxsize)/2,(2*y-options.outputboxsize)/2, (2*z-options.outputboxsize)/2, options.outputboxsize, options.outputboxsize, options.outputboxsize)
		e = EMData()
		e.read_image(options.tomogram,0,False,r)
		
		e.process_inplace('normalize.edgemean')
		
		min = e['minimum']
		max = e['maximum']
		#print "min and max of ptcl are", min, max
		if tag=='gold':
			#print "tag is", tag
			#print "and mean_maxs and sigma_maxs are", mean_maxs, sigma_maxs
			#print "and mean_mins and sigma_mins are", mean_mins, sigma_mins
			if max > (mean_maxs - (sigma_maxs * 3)) or min < (mean_mins - (sigma_mins * 3)):
				data.remove(d)
				#print "particle REMOVED based on GOLD PRUNING!"
		elif tag == 'background':
			 if max < (mean_maxs + sigma_maxs):
				data.remove(d)
				#print "particle REMOVED based on BACKGROUND PRUNING!"
		elif tag == 'carbon':
			print "NO cabron pruning method yet"			
	
	return (data)


#def generateref(options):
#	ptclhdr = EMData(options.ptclstack,0,True)
#	box = ptclhdr['nx']
#	outputboxsize = box
#	if options.outputboxsize:
#		outputboxsize == options.outputboxsize
#		
#	#genrefpath = options.path + "/genref"
#	#os.system('mkdir ' + genrefpath)
#	cmd = "cd " + options.path + " && e2spt_classaverage.py --path=genref --input=../" + options.ptclstack + " --output=" + options.ptclstack.replace('.hdf','_avg.hdf') + " --npeakstorefine=10 -v 0 --mask=mask.sharp:outer_radius=-2 --lowpass=filter.lowpass.gauss:cutoff_freq=.02 --align=rotate_translate_3d:search=" +str( int(box/4) ) + ":delta=15:dphi=15:verbose=0 --parallel=thread:7 --ralign=refine_3d_grid:delta=5:range=15:search=2 --averager=mean.tomo --aligncmp=ccc.tomo --raligncmp=ccc.tomo --savesteps --saveali --normproc=normalize.mask"
#	if options.verbose:
#		print "I will generate a template from --particlestack by executing the following command:", cmd
#	
#	os.system(cmd)
#	options.template = options.path + "/genref/" + options.ptclstack.replace('.hdf','_avg.hdf')
#	return(options, outputboxsize)
	

def scanposition(options,template,outputboxsize,yshort,xi,yi,zi,xc,yc,zc,sbn,x,y,xo,yo,count):

	#print "\n\nThese are the parameters received in scanposition function: xi=%d, OtherLongI=%d, xc=%d, OtherLongC=%d, zc=%d" %(xi,yi,xc,yc,zc)
	#print " I am scanning SUBREGION", sbn+1
	expandedtemplateboxsize = template['nx']
	ptclmaskrad = outputboxsize/2
	if options.ptclradius:
		ptclmaskrad = options.ptclradius -1
	
	aux=0
	aux2=0
	aux3=0
	if yshort:
		print "YSHOTRT IS ON!!!!!!!!!!!!!!!"
		
		aux2=yi
		yi=zi
		zi=aux2
		
		aux3=yc
		yc=zc
		zc=aux3
	#else:
		#print "ZSHORT!!!!!"
	#	print ''
		
	r = Region( xi, yi, zi, expandedtemplateboxsize, expandedtemplateboxsize, expandedtemplateboxsize )

	#print "\n\n$$$$$$$$$The coordinates of subregion %d are " %(sbn+1)
	#print xi, yi, zi, xi+expandedtemplateboxsize, yi+expandedtemplateboxsize, zi+expandedtemplateboxsize
	#print "$$$$$$$$\n\n"
	
	subox = EMData()
	subox.read_image(options.tomogram,0,False,r)
	subox['origin_x']=0
	subox['origin_y']=0
	subox['origin_z']=0
	
	tomohdr=EMData(options.tomogram,0,True)
	subox['apix_x']=tomohdr['apix_x']
	subox['apix_y']=tomohdr['apix_y']
	subox['apix_z']=tomohdr['apix_z']
	
	#subox.write_image('subregion' +str(sbn+1).zfill(3) + '.hdf',0)
	#print "The dimensions of the EXTRACTED subox to write are", subox['nx'],subox['ny'],subox['nz']
	
	#if options.invert:
	#	subox.mult(-1)
	
	#print"Count is", count
	if subox['mean']:
		#subox.process_inplace('normalize')
		nptcls = int( round( ( (expandedtemplateboxsize * expandedtemplateboxsize * expandedtemplateboxsize) / (outputboxsize * outputboxsize * outputboxsize * options.concentrationfactor ) ) ) )
		#print "Nptcls based on volume per subox is", nptcls		
		if options.test:
			nptcls = 1	
		suboxnorm=subox.process('normalize.edgemean')
		
		if options.goldthreshtomo and options.goldstack:
			#print "I will THRESHOLD the subsection based on gold stats"
			#goldstack = os.path.base(options.goldstack)
			#print "Gold stack received is", options.goldstack
			#ret = meancalc(options, options.goldstack ,normalize=True)
			#max_m = ret[0]
			#max_s = ret[1]
			
			#min_m = ret[2]
			#min_s = ret[3]
			
			#print "The mean of the gold maxes is", max_m
			#print "The mean of the gold minimums is", min_m
			#max_val = max_m - 30 * max_s
			#min_val = min_m + 5 * math.fabs(min_s)
			#print "Therefore the max val to filter is", max_val
			#print "the min is", min_val
			
			#print "BEFORE CLAMPING, max and min are", suboxnorm['maximum'],suboxnorm['minimum']
			#print "count is", count
			suboxnorm.process_inplace('threshold.clampminmax',{'maxval':2,'minval':-1,'tozero':1})
			suboxnorm.write_image('clamped.hdf',count)
			
			#print "AFTER CLAMPING, max and min", suboxnorm['maximum'],suboxnorm['minimum']
			
		ccf = template.calc_ccf(suboxnorm)
		ccf.process_inplace("xform.phaseorigin.tocorner") 
		ccf.process_inplace('normalize')
		#ccf.write_image('subregion' +str(sbn+1).zfill(3) + '_ccf.hdf',0)
		#print "\n\n\n\n\n\n DDDDDDDDDDDD"
		#print "The volume of the region is", expandedtemplateboxsize * expandedtemplateboxsize * expandedtemplateboxsize
		#print "Whereas that of the output is", outputboxsize * outputboxsize * outputboxsize
		#print "And therefore their ratio is", (expandedtemplateboxsize * expandedtemplateboxsize * expandedtemplateboxsize) / (outputboxsize * outputboxsize * outputboxsize)
		#print "The maximum is", ccf['maximum'] 
		#print "And it is at", ccf.calc_max_location()
		#print "\n\nThe potential number of particles in this subregion is", nptcls
		#print "\n\nDDDDDDDDDDDD\n\n\n\n\n\n"
		coordssubset = set()
		
		results=[]
		masks=[]
		
		xmax=0
		ymax=0
		zmax=0
		
		#edgeminval = ptclmaskrad
		#edgemaxval = expandedtemplateboxsize - ptclmaskrad
		
		edgeminval = int(options.ptclradius) - 2
		edgemaxval = expandedtemplateboxsize - int(options.ptclradius/2) + 2
		#print "Edge min and max vals are", edgeminval, edgemaxval
		#print "\n\n\nThe number of particles to look for in a subregion is %d\n\n\n" %(nptcls)
		for p in range(nptcls):
		 	#print "\nAttempt numbr %d to find a particle" %(p)
			#print "in subregion", sbn+1
			#box = ccf.get_zsize()
			#r =  Region((box/2) - int(parameters['searchx']), (box/2) - int(parameters['searchy']), (box/2) - int(parameters['searchz']), 2 * int(parameters['searchx']) + 1, 2 * int(parameters['searchy']) + 1, 2 * int(parameters['searchz']) + 1) 
			#sub_ccf = ccf.get_clip(r)	

			locmax = ccf.calc_max_location()
									
			locmaxX = locmax[0]
			locmaxY = locmax[1]
			locmaxZ = locmax[2]
			
			max = ccf['maximum']
			
			#print "Therefore, after subtracting this max from the subbox, the max is at", xmax,ymax,zmax
			#if max < 1.0
			if locmaxX < edgeminval or locmaxX > edgemaxval or locmaxY < edgeminval or locmaxY > edgemaxval or locmaxZ < edgeminval or locmaxZ > edgemaxval:
				#print "Either the max was less than 1; lets see", max
				#print "Or one of the coordinates of the maximum was too close to the edge", locmax
				#print "A particle has been skipped based on EDGE VALUES!"
				pass			
			else:
				#print "THE max for a potential particle was found at", locmax
				aux=0
				if yshort:
					print "YSHORT IS TURNED ON!"
					aux=ymax
					ymax=zmax
					zmax=aux
				
				#print "The SUBREGION BOXSIZE or expandedtemplateboxsize for this thing is", expandedtemplateboxsize
				#print "And max value is", max
				
				realxmax = (expandedtemplateboxsize - locmaxX) + xi
				realymax = (expandedtemplateboxsize - locmaxY) + yi
				realzmax = (expandedtemplateboxsize - locmaxZ) + zi
				
				go=True
				if options.mask and options.gridradius:
					print "Because mask is on, I will see if the real center of the putative particle is within"
					if (realxmax - (xo + x)) * (realxmax - (xo + x)) + (realymax - (yo + y)) * (realymax - (yo + y)) < (options.gridradius * options.gridradius) :
						print "particle inside mask!"
					else:
						go=False
						print "Particle outside mask!"
				if go:

				#print "Therefore, the REAL final coordinates are", realxmax,realymax,realzmax	
					maskx=locmaxX - expandedtemplateboxsize/2
					masky=locmaxY - expandedtemplateboxsize/2
					maskz=locmaxZ - expandedtemplateboxsize/2
				
				#maskx = (expandedtemplateboxsize - locmaxX)
				#masky = (expandedtemplateboxsize - locmaxY)
				#maskz = (expandedtemplateboxsize - locmaxZ)
				
				#print "Therefore the mask will be centered at", maskx,masky,maskz
					ccf.process_inplace('mask.sharp',{'inner_radius':ptclmaskrad,'dx':maskx,'dy':masky,'dz':maskz})
				#ccf.process_inplace('mask.sharp',{'inner_radius':ptclmaskrad,'dx':xmax-subboxsiz/2,'dy':ymax-subboxsiz/2,'dz':zmax-subboxsiz/2})
				#print "\nThe ptclmaskrad used is\n", ptclmaskrad
				#print "\n\n"
				#ccf.write_image('subregion' +str(sbn+1).zfill(3) + '_ccf_mask' + str(p).zfill(3)+ '.hdf',0)				
					results.append([max,realxmax,realymax,realzmax])
				#coordssubset.add(( realxmax, realymax, realzmax )) 
				
				#if xi<80 and p == 2:
				#	print "$$$$$$$$$$$$$$$$$$$ I will write the melon ball!"
				#	ccf.write_image('zzmelonedball.hdf',0)
		return(results)
	else:
		print "You're scanning empty regions of the tomogram. You might have a --yshort tomogram and haven't realized so."
		return(None)
		
if '__main__' == __name__:
	main()
	
	
	
	
	
	
	
